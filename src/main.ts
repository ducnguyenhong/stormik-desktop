import { app, BrowserWindow, ipcMain, WebContentsView } from 'electron';
import Store from 'electron-store';
import { v4 as uuidV4 } from 'uuid';
import { DEFAULT_BOOKMARK_LIST, effectChangeBookmarks, getBookmarkList, setBookmarkList } from './function/bookmark';
import { showContextMenu, showCustomizeMenu } from './function/common';
import {
  addTabsLength,
  createNewTab,
  effectChangeTabs,
  getCurrentTabId,
  getTabList,
  getTabsLength,
  setCurrentTabId,
  setTabList
} from './function/tab';
import { TabContentView } from './types/tab.type';
import {
  HOME_DOMAIN_INCOGNITO,
  HOME_DOMAIN_NORMAL,
  INCOGNITO_KEY,
  SHOW_DEVTOOL_STORE_KEY,
  TABS_STORE_KEY
} from './utils/const';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

const store: any = new Store();

export const CONTROL_HEIGHT = 115.5; // px
// export const CONTROL_HEIGHT = 600; // px

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

let tabsContentView: TabContentView[] = [];

const createWindow = (defaultTabId?: string): void => {
  const windowId = uuidV4();
  const firstTabId = defaultTabId || uuidV4();

  if (!defaultTabId) {
    setTabList(store, []);
  }

  const isIncognito = store.get(INCOGNITO_KEY);

  let HOME_DOMAIN = isIncognito ? HOME_DOMAIN_INCOGNITO : HOME_DOMAIN_NORMAL;
  if (defaultTabId) {
    const tabList = getTabList(store);
    const currentTab = tabList.find((i) => i.id === defaultTabId);
    if (currentTab) {
      HOME_DOMAIN = currentTab.url;
    }
  }

  const mainWindow = new BrowserWindow({
    x: 0,
    y: defaultTabId ? 100 : 0,
    height: defaultTabId ? 980 : 1080,
    width: defaultTabId ? 1920 : 1920,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      sandbox: true,
      webviewTag: true,
      nodeIntegration: true
    },
    titleBarStyle: 'hidden',
    titleBarOverlay: {
      color: isIncognito ? '#4f4f4f' : '#e6e6e6',
      symbolColor: '#262626',
      height: 40
    }
  });

  mainWindow.removeMenu();
  if (!defaultTabId) {
    mainWindow.maximize();
  }

  const controlView = new WebContentsView({
    webPreferences: {
      // contextIsolation: true,
      // nodeIntegration: true,
      // allowRunningInsecureContent: true,
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY
    }
  });
  const bodyView = new WebContentsView({
    webPreferences: {
      // contextIsolation: true,
      nodeIntegration: true,
      // allowRunningInsecureContent: true,
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      sandbox: true
    }
  });
  mainWindow.contentView.addChildView(controlView, 1000000000);
  mainWindow.contentView.addChildView(bodyView, 0);

  controlView.setBounds({
    x: 0,
    y: 0,
    width: mainWindow.getContentBounds().width,
    height: CONTROL_HEIGHT
  });
  controlView.webContents.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  bodyView.setBounds({
    x: 0,
    y: CONTROL_HEIGHT,
    width: mainWindow.getContentBounds().width,
    height: mainWindow.getContentBounds().height - CONTROL_HEIGHT
  });

  bodyView.webContents.loadURL(HOME_DOMAIN).then(() => {
    const isIncognito = store.get(INCOGNITO_KEY);
    store.set(TABS_STORE_KEY, [
      {
        title: defaultTabId ? bodyView.webContents.getTitle() : 'Thẻ mới',
        url: HOME_DOMAIN,
        id: firstTabId,
        isActive: true
      }
    ]);
    setCurrentTabId(store, firstTabId);
    const newTabList = [];
    newTabList.push({
      id: firstTabId,
      index: 0,
      isActive: true,
      title: defaultTabId ? bodyView.webContents.getTitle() : 'Thẻ mới',
      url: HOME_DOMAIN,
      isLoading: false,
      windowId
    });
    tabsContentView.push({ view: bodyView, tabId: firstTabId, windowId });
    addTabsLength(store);
    setTabList(store, newTabList);
    effectChangeTabs(controlView, newTabList);
    controlView.webContents.send('effect-incognito', isIncognito);
    setTimeout(() => {
      controlView.webContents.send('effect-new-tab', true);
    }, 1000);

    const bookmarkList = getBookmarkList(store);
    const defaultBookmarkList = bookmarkList.length ? bookmarkList : DEFAULT_BOOKMARK_LIST;
    setBookmarkList(store, defaultBookmarkList);
    effectChangeBookmarks(controlView, defaultBookmarkList);
    if (isIncognito) {
      mainWindow.webContents.session.clearCache();
      mainWindow.webContents.session.clearStorageData();
    }
  });

  bodyView.webContents.on('did-navigate', (e, url) => {
    // addHistory(store, {
    //   url,
    //   type: 'URL',
    //   domain: getDomainName(url),
    //   title: bodyView.webContents.getTitle()
    // });

    const oldTabList = getTabList(store);
    const newTabList = oldTabList.map((item) => {
      if (item.id === firstTabId) {
        return {
          ...item,
          url,
          title: bodyView.webContents.getTitle(),
          isLoading: true
        };
      }
      return item;
    });
    setTabList(store, newTabList);
    effectChangeTabs(controlView, newTabList);
  });

  bodyView.webContents.on('did-navigate-in-page', (e, url) => {
    // addHistory(store, {
    //   url,
    //   type: 'URL',
    //   domain: getDomainName(url),
    //   title: bodyView.webContents.getTitle()
    // });

    const oldTabList = getTabList(store);
    const newTabList = oldTabList.map((item) => {
      if (item.id === firstTabId) {
        return {
          ...item,
          url,
          title: bodyView.webContents.getTitle()
        };
      }
      return item;
    });
    setTabList(store, newTabList);
    effectChangeTabs(controlView, newTabList);
  });

  bodyView.webContents.on('did-finish-load', () => {
    const oldTabList = getTabList(store);
    const newTabList = oldTabList.map((item) => {
      if (item.id === firstTabId) {
        return {
          ...item,
          title: bodyView.webContents.getTitle(),
          isLoading: false
        };
      }
      return item;
    });
    setTabList(store, newTabList);
    effectChangeTabs(controlView, newTabList);
  });

  bodyView.webContents.setWindowOpenHandler((data) => {
    createNewTab({
      mainWindow,
      controlView,
      tabsContentView,
      setTabsContentView: (tabsContent: TabContentView[]) => {
        tabsContentView = tabsContent;
      },
      store,
      preloadUrl: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      newUrl: data.url,
      nextTabLength: getTabsLength(store) + 1
    });
    return { action: 'deny' };
  });

  ipcMain.on('url-enter', (_event, url) => {
    const currentTabId = getCurrentTabId(store);
    const tabList = getTabList(store);
    const currentTabView = tabsContentView.find((i) => i.tabId === currentTabId);
    currentTabView?.view?.webContents?.loadURL(url);

    const newTabList = tabList.map((item) => ({ ...item, url: currentTabId === item.id ? url : item.url }));

    setTabList(store, newTabList);
    effectChangeTabs(controlView, newTabList);
  });

  ipcMain.on('load-bookmark-url', (_event, url) => {
    const currentTabId = getCurrentTabId(store);
    const tabList = getTabList(store);
    const currentTabView = tabsContentView.find((i) => i.tabId === currentTabId);
    currentTabView?.view?.webContents?.loadURL(url);

    const newTabList = tabList.map((item) => ({ ...item, url: currentTabId === item.id ? url : item.url }));

    setTabList(store, newTabList);
    effectChangeTabs(controlView, newTabList);
  });

  ipcMain.on('save-bookmark', () => {
    const currentTabId = getCurrentTabId(store);
    const tabList = getTabList(store);
    const currentTab = tabList.find((i) => i.id === currentTabId);
    const currentUrl = currentTab?.url;
    const currentTitle = currentTab?.title;

    const bookmarkList = getBookmarkList(store);
    const isExists = !!bookmarkList.find((i) => i.url === currentUrl);

    if (!isExists) {
      const newBookmark = {
        id: uuidV4(),
        title: currentTitle,
        url: currentUrl
      };
      const newBookmarkList = [...bookmarkList, newBookmark];
      setBookmarkList(store, newBookmarkList);
      effectChangeBookmarks(controlView, newBookmarkList);
    }
  });

  ipcMain.on('remove-bookmark', (_event, id: string) => {
    const bookmarkList = getBookmarkList(store);
    const newBookmarkList = bookmarkList.filter((i) => i.id !== id);
    setBookmarkList(store, newBookmarkList);
    effectChangeBookmarks(controlView, newBookmarkList);
  });

  ipcMain.on('reload-page', () => {
    const currentTabId = getCurrentTabId(store);
    const currentTabView = tabsContentView.find((i) => i.tabId === currentTabId);
    currentTabView?.view?.webContents?.reload();
  });

  ipcMain.on('new-tab', () => {
    createNewTab({
      mainWindow,
      controlView,
      tabsContentView,
      setTabsContentView: (tabsContent: TabContentView[]) => {
        tabsContentView = tabsContent;
      },
      store,
      preloadUrl: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      newUrl: HOME_DOMAIN,
      nextTabLength: getTabsLength(store) + 1
    });
  });

  ipcMain.on('new-window-from-tab', (_event, tabId: string) => {
    if (!defaultTabId) {
      createWindow(tabId);

      const currentTabId = getCurrentTabId(store);
      const isCurrentTab = tabId === currentTabId;
      const tabList = getTabList(store);
      const closeTabIndex = tabList.findIndex((i) => i.id === tabId);

      if (closeTabIndex) {
        tabsContentView?.[closeTabIndex]?.view?.webContents?.close();
        tabsContentView?.[closeTabIndex]?.view?.setVisible(false);
      }

      const newTabList = tabList
        .filter((i) => i.id !== tabId)
        .map((i, idx) => ({ ...i, isActive: isCurrentTab ? idx === 0 : i.isActive }));

      tabsContentView = tabsContentView.filter((i) => i.tabId !== tabId);

      if (isCurrentTab) {
        for (let i = 0; i < tabsContentView.length; i++) {
          if (i === 0) {
            tabsContentView?.[i]?.view?.setVisible(true);
          } else {
            tabsContentView?.[i]?.view?.setVisible(false);
          }
        }
      }
      setCurrentTabId(store, newTabList[0].id);
      setTabList(store, newTabList);
      effectChangeTabs(controlView, newTabList);
    }
  });

  ipcMain.on('change-tab', (_event, tabId: string) => {
    const tabList = getTabList(store);

    for (let i = 0; i < tabsContentView.length; i++) {
      if (tabsContentView[i].tabId === tabId) {
        tabsContentView?.[i]?.view?.setVisible(true);
      } else {
        tabsContentView?.[i]?.view?.setVisible(false);
      }
    }

    const newTabList = tabList.map((i) => ({ ...i, isActive: i.id === tabId }));
    setCurrentTabId(store, tabId);
    setTabList(store, newTabList);
    effectChangeTabs(controlView, newTabList);
  });

  ipcMain.on('close-tab', (_event, tabId: string) => {
    const currentTabId = getCurrentTabId(store);
    const isCurrentTab = tabId === currentTabId;
    const tabList = getTabList(store);
    const closeTabIndex = tabList.findIndex((i) => i.id === tabId);

    if (closeTabIndex) {
      tabsContentView?.[closeTabIndex]?.view?.webContents?.close();
      tabsContentView?.[closeTabIndex]?.view?.setVisible(false);
    }

    const newTabList = tabList
      .filter((i) => i.id !== tabId)
      .map((i, idx) => ({ ...i, isActive: isCurrentTab ? idx === 0 : i.isActive }));

    tabsContentView = tabsContentView.filter((i) => i.tabId !== tabId);

    if (isCurrentTab) {
      for (let i = 0; i < tabsContentView.length; i++) {
        if (i === 0) {
          tabsContentView?.[i]?.view?.setVisible(true);
        } else {
          tabsContentView?.[i]?.view?.setVisible(false);
        }
      }
    }
    setCurrentTabId(store, newTabList[0].id);
    setTabList(store, newTabList);
    effectChangeTabs(controlView, newTabList);
  });

  ipcMain.on('prev-page', () => {
    const currentTabId = getCurrentTabId(store);
    const currentTabView = tabsContentView.find((i) => i.tabId === currentTabId);
    currentTabView?.view?.webContents?.goBack();
    // const lastHistory = getLastHistory(store);
    // const currentTabId = getCurrentTabId(store);
    // const tabList = getTabList(store);
    // const currentTabIndex = tabList.findIndex((i) => i.id === currentTabId);

    // if (lastHistory?.url) {
    //   if (currentTabIndex) {
    //     tabsContentView?.[currentTabIndex]?.view?.webContents?.loadURL(lastHistory.url);
    //   }

    //   updateWhenPrevHistory(store);
    // }
  });

  ipcMain.on('show-context-menu', (event, targetData: any) => {
    showContextMenu({
      event,
      mainWindow,
      controlView,
      tabsContentView,
      setTabsContentView: (tabsContent: TabContentView[]) => {
        tabsContentView = tabsContent;
      },
      store,
      preloadUrl: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      targetData
    });
  });

  ipcMain.on('open-customize', (event) => {
    showCustomizeMenu({
      event,
      mainWindow,
      controlView,
      tabsContentView,
      setTabsContentView: (tabsContent: TabContentView[]) => {
        tabsContentView = tabsContent;
      },
      store,
      preloadUrl: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      app
    });
  });

  bodyView.webContents.on('devtools-closed', () => {
    const showDevtool = store.get(SHOW_DEVTOOL_STORE_KEY);
    if (showDevtool) {
      store.set(SHOW_DEVTOOL_STORE_KEY, false);
    }
  });

  // controlView.webContents.openDevTools();

  // Open the DevTools.
  bodyView.webContents.on('before-input-event', (event, input) => {
    if (input.key === 'F12') {
      event.preventDefault();
      const showDevtool = store.get(SHOW_DEVTOOL_STORE_KEY);
      if (showDevtool) {
        store.set(SHOW_DEVTOOL_STORE_KEY, false);
        bodyView.webContents.closeDevTools();
      } else {
        store.set(SHOW_DEVTOOL_STORE_KEY, true);
        bodyView.webContents.openDevTools();
      }
    }

    if (input.control && input.key.toLowerCase() === 't') {
      createNewTab({
        mainWindow,
        controlView,
        tabsContentView,
        setTabsContentView: (tabsContent: TabContentView[]) => {
          tabsContentView = tabsContent;
        },
        store,
        preloadUrl: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        newUrl: HOME_DOMAIN,
        nextTabLength: getTabsLength(store) + 1
      });
    }

    if (input.control && input.shift && input.key.toLowerCase() === 'n') {
      const isIncognito = store.get(INCOGNITO_KEY);
      store.set(INCOGNITO_KEY, !isIncognito);
      app.relaunch();
      app.exit();
    }
  });

  mainWindow.on('close', () => {
    const isIncognito = store.get(INCOGNITO_KEY);
    if (isIncognito) {
      mainWindow.webContents.session.clearCache();
      mainWindow.webContents.session.clearStorageData();
    }
  });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => createWindow());

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
